---
title: "scPred Label Transfer — GSE SMART-seq2 Reference"
output: html_document
date: "`r Sys.Date()`"
---

# scPred Classification: GSE SMART-seq2 Reference → In-house Query

This notebook trains a scPred classifier on three aggregated SMART-seq2 datasets
(GSE128003, GSE128074, GSE106973) and predicts cell type labels on the in-house
query dataset (MC_LPMC_072424).

## Module 1: Setup & Configuration


```{r setup, include=FALSE}
library(Seurat)
library(SeuratObject)
library(BiocManager)
library(tidyverse)
library(SeuratWrappers)
library(dplyr)
library(ggplot2)
library(ggridges)
library(scCustomize)
library(svglite)
library(tidyquant)
library(openxlsx)
library(harmony)
library(scPred)
library(biomaRt)
library(GEOquery)
library(data.table)
library(Matrix)

# ---- Create output directory ----
dir.create("plots", showWarnings = FALSE)

# ---- User-configurable paths ----
data_dir   <- "."                           # <-- set to directory containing data files
query_path <- file.path(data_dir, "MC_LPMC_072424.rds")

ref_files <- c(
  file.path(data_dir, "GSE128003_HTSeq_counts.txt.gz"),
  file.path(data_dir, "GSE128074_HTSeq_counts.txt.gz"),
  file.path(data_dir, "GSE106973_HTSeq_counts.txt.gz")
)

# ---- Helper: save plot as .svg + .png and print inline ----
save_and_show <- function(p, name, width = 10, height = 7, dpi = 300) {
  ggsave(file.path("plots", paste0(name, ".png")), plot = p,
         width = width, height = height, dpi = dpi)
  ggsave(file.path("plots", paste0(name, ".svg")), plot = p,
         width = width, height = height, device = svglite::svglite)
  print(p)
}

# ---- Helper: save base R plots as .svg + .png ----
save_base_plot <- function(expr, name, width = 10, height = 7, dpi = 300) {
  png(file.path("plots", paste0(name, ".png")),
      width = width, height = height, units = "in", res = dpi)
  eval(expr)
  dev.off()

  svglite::svglite(file.path("plots", paste0(name, ".svg")),
                   width = width, height = height)
  eval(expr)
  dev.off()

  # Print inline
  eval(expr)
}
```

## Module 1b: Download GSE Reference Data

```{r download-gse-data, message=FALSE}
# Download HTSeq count files from GEO if not already present
gse_accessions <- c("GSE128003", "GSE128074", "GSE106973")

for (acc in gse_accessions) {
  dest <- file.path(data_dir, paste0(acc, "_HTSeq_counts.txt.gz"))
  if (file.exists(dest)) {
    message(acc, " already present — skipping download.")
    next
  }
  message("Downloading supplementary files for ", acc, " ...")
  supp <- getGEOSuppFiles(acc, baseDir = tempdir(),
                          filter_regex = "HTSeq_counts")
  downloaded <- rownames(supp)
  match_file <- downloaded[grep("HTSeq_counts", downloaded)]
  if (length(match_file) == 0) stop("No HTSeq_counts file found for ", acc)
  file.copy(match_file[1], dest)
  message("  -> saved to ", dest)
}
```

## Module 2: Load SMART-seq2 Reference Data

```{r load-reference-data, message=FALSE}
# Read each file and extract cell type labels from column names
read_smartseq2 <- function(fp) {
  dt <- fread(fp, nThread = max(1, parallel::detectCores() - 1))
  stopifnot("ID" %in% names(dt))

  # Remove ERCC spike-ins and blank/underscore-prefixed rows
  dt <- dt[!grepl("^(ERCC|_)", ID) & !is.na(ID) & ID != ""]

  # Preserve gene IDs separately before removing the column
  gene_ids <- dt$ID

  # Extract cell names (all columns except ID)
  cell_names <- setdiff(names(dt), "ID")

  # Extract cell type labels: everything before the trailing _<integer>
  cell_labels <- sub("_\\d+$", "", cell_names)

  list(dt = dt, gene_ids = gene_ids, cell_names = cell_names,
       cell_labels = cell_labels, source_file = basename(fp))
}

ref_data_list <- lapply(ref_files, read_smartseq2)
names(ref_data_list) <- basename(ref_files)

# Preview cell type labels per file
for (nm in names(ref_data_list)) {
  cat("\n", nm, ":\n")
  print(table(ref_data_list[[nm]]$cell_labels))
}
```
##Module 3 - Load il-9 datset
```{r}
query_path     <- file.path(data_dir, "MC_LPMC_072424.rds")
obj_b <- readRDS(query_path)
```

```{r} 

## Module 3: Convert ENSMUSG to Gene Symbols

```{r convert-ensmusg, message=FALSE}
# Collect all unique ENSMUSG IDs across files (strip version suffix)
all_ensmusg <- unique(unlist(lapply(ref_data_list, function(x) {
  sub("\\.\\d+$", "", x$dt$ID)
})))

cat("Total unique ENSMUSG IDs:", length(all_ensmusg), "\n")

# Query biomaRt for ENSMUSG → MGI symbol mapping
mart <- useEnsembl(biomart = "genes", dataset = "mmusculus_gene_ensembl")
mapping_tbl <- getBM(
  attributes = c("ensembl_gene_id", "mgi_symbol"),
  filters    = "ensembl_gene_id",
  values     = all_ensmusg,
  mart       = mart
)

# Build lookup: ENSMUSG → symbol
sym_lookup <- setNames(rep(NA_character_, length(all_ensmusg)), all_ensmusg)
idx <- match(all_ensmusg, mapping_tbl$ensembl_gene_id)
sym_lookup[!is.na(idx)] <- mapping_tbl$mgi_symbol[idx[!is.na(idx)]]

# Fallback: keep ENSMUSG ID if no symbol or empty symbol
sym_lookup[is.na(sym_lookup) | sym_lookup == ""] <-
  names(sym_lookup)[is.na(sym_lookup) | sym_lookup == ""]

cat("Mapped to symbol:", sum(!grepl("^ENSMUSG", sym_lookup)), "/", length(sym_lookup), "\n")
cat("\nExample mappings:\n")
print(head(data.table(ensembl = names(sym_lookup), symbol = unname(sym_lookup)), 10))

# Apply conversion to each data.table and collapse duplicate symbols by MAX
convert_to_symbols <- function(rd) {
  dt <- copy(rd$dt)

  # Map ENSMUSG → symbol
  ens_core <- sub("\\.\\d+$", "", dt$ID)
  dt[, ID := sym_lookup[ens_core]]

  # Ensure numeric count columns
  num_cols <- setdiff(names(dt), "ID")
  for (cc in num_cols) dt[[cc]] <- as.numeric(dt[[cc]])

  # Collapse duplicate gene symbols by per-cell MAX
  dt <- dt[, lapply(.SD, max), by = ID, .SDcols = num_cols]

  # Update gene_ids to reflect new symbols
  rd$dt <- dt
  rd$gene_ids <- dt$ID
  rd
}

ref_data_list <- lapply(ref_data_list, convert_to_symbols)

cat("\nGenes after symbol conversion (per file):\n")
for (nm in names(ref_data_list)) {
  cat("  ", nm, ":", nrow(ref_data_list[[nm]]$dt), "genes\n")
}
```

## Module 4: Combine into Seurat Reference Object

```{r create-reference-seurat, message=FALSE}
# Build individual Seurat objects with cell type metadata
build_seurat <- function(rd) {
  dt <- copy(rd$dt)

  # Use stored gene_ids; drop ID column only if it exists
  genes <- rd$gene_ids
  if ("ID" %in% names(dt)) dt[, ID := NULL]

  mat <- as.matrix(dt)
  rownames(mat) <- genes
  mat <- as(mat, "sparseMatrix")
  colnames(mat) <- rd$cell_names

  # Verify gene names are properly assigned
  stopifnot(!any(grepl("^Feature\\d+$", rownames(mat))))

  obj <- CreateSeuratObject(counts = mat, assay = "RNA",
                            project = rd$source_file)
  obj$cell_type <- rd$cell_labels
  obj$source_file <- rd$source_file
  obj
}

seurat_list <- lapply(ref_data_list, build_seurat)

# Find common genes across all datasets
common_genes <- Reduce(intersect, lapply(seurat_list, rownames))
cat("Common genes across all 3 datasets:", length(common_genes), "\n")
seurat_list <- lapply(seurat_list, function(s) subset(s, features = common_genes))

# Merge into a single reference object
obj_a <- merge(seurat_list[[1]], y = seurat_list[-1],
                   add.cell.ids = paste0("ref", seq_along(seurat_list)))

# Join layers so counts is a single matrix (Seurat v5)
obj_a[["RNA"]] <- JoinLayers(obj_a[["RNA"]])

# QC: remove zero-count cells and ultra-rare genes
counts_mat <- LayerData(obj_a, layer = "counts")
keep_cells <- Matrix::colSums(counts_mat) > 0
keep_genes <- Matrix::rowSums(counts_mat > 0) >= 3
obj_a <- obj_a[keep_genes, keep_cells]

# Set cell type as Idents
Idents(obj_a) <- "cell_type"
cat("obj_a object:", ncol(obj_a), "cells,", nrow(obj_a), "genes\n")
cat("Cell types:\n")
print(table(Idents(obj_a)))

# Verify gene names
cat("\nFirst 10 gene names:\n")
print(head(rownames(obj_a), 10))
```

## Module 5: Preprocess obj_a for scPred

```{r preprocess-obj_a, message=FALSE}
obj_a <- NormalizeData(obj_a, verbose = FALSE)
obj_a <- FindVariableFeatures(obj_a, selection.method = "vst",
                                  nfeatures = 3000, verbose = FALSE)
obj_a <- ScaleData(obj_a, verbose = FALSE)
obj_a <- RunPCA(obj_a, npcs = min(50, ncol(obj_a) - 1), verbose = FALSE)
obj_a <- RunUMAP(obj_a, dims = 1:30, verbose = FALSE)

p_ref_umap <- DimPlot(obj_a, group.by = "cell_type", label = TRUE,
                       repel = TRUE) +
  ggtitle("obj_a UMAP — Cell Types")
save_and_show(p_ref_umap, "gse_ref_umap_celltypes")
```


## Module 7: Load Query Data

```{r load-query, message=FALSE}
query <- readRDS(query_path)
cat("Query object loaded:", ncol(query), "cells,", nrow(query), "genes\n")
cat("Assays:", paste(Assays(query), collapse = ", "), "\n")

# Ensure we work with the RNA assay and a single counts layer
DefaultAssay(query) <- "RNA"

# If Seurat v5 with multiple count layers, join them
cnt_layers <- grep("^counts", Layers(query[["RNA"]]), value = TRUE)
if (length(cnt_layers) > 1) {
  cat("Joining", length(cnt_layers), "count layers ...\n")
  query[["RNA"]] <- JoinLayers(query[["RNA"]])
}

# Normalize and preprocess query
query <- NormalizeData(query, verbose = FALSE)
query <- FindVariableFeatures(query, selection.method = "vst",
                              nfeatures = 3000, verbose = FALSE)
query <- ScaleData(query, verbose = FALSE)
query <- RunPCA(query, npcs = min(50, ncol(query) - 1), verbose = FALSE)

# Compute UMAP if not already present
if (!"umap" %in% Reductions(query)) {
  query <- RunUMAP(query, dims = 1:30, verbose = FALSE)
}

# Cluster if not already clustered
if (is.null(query$seurat_clusters)) {
  query <- FindNeighbors(query, dims = 1:30, verbose = FALSE)
  query <- FindClusters(query, resolution = 0.5, verbose = FALSE)
}

cat("Query preprocessed:", ncol(query), "cells,", nrow(query), "genes\n")
cat("\nFirst 10 gene names in reference:\n")
print(head(rownames(reference), 10))
```



---

**Session Info**

```{r session-info}
sessionInfo()
```
