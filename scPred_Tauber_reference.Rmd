---
title: "scPred Label Transfer — Tauber Reference"
output: html_document
date: "`r Sys.Date()`"
---

# scPred Classification: Tauber/Mice Mast Cells Reference → In-house Query

This notebook trains a scPred classifier on the Tauber mast cell dataset
(Mice_Mast_cells.rds) — which already contains gene symbols and cell type
annotations — and predicts cell type labels on the in-house query dataset
(MC_LPMC_072424).

## Module 1: Libraries

```{r setup, message=FALSE, warning=FALSE}
library(Seurat)
library(SeuratObject)
library(BiocManager)
library(devtools)
library(tidyverse)
library(rsvd)
library(SeuratWrappers)
library(dplyr)
library(ggplot2)
library(ggridges)
library(clustree)
library(scCustomize)
library(Nebulosa)
library(svglite)
library(tidyquant)
library(openxlsx)
library(harmony)
library(scPred)
library(biomaRt)
library(GEOquery)
library(data.table)
library(Matrix)
```


## Module 2: Setup 
```{r}
# ---- Create output directory ----
dir.create("plots", showWarnings = FALSE)

# ---- User-configurable paths ----
data_dir       <- "."                                       # <-- set to directory containing data files
query_path     <- file.path(data_dir, "MC_LPMC_072424.rds")
reference_path <- file.path(data_dir, "Mice_Mast_cells.rds")

# ---- Helper: save plot as .svg + .png and print inline ----
save_and_show <- function(p, name, width = 10, height = 7, dpi = 300) {
  ggsave(file.path("plots", paste0(name, ".png")), plot = p,
         width = width, height = height, dpi = dpi)
  ggsave(file.path("plots", paste0(name, ".svg")), plot = p,
         width = width, height = height, device = svglite::svglite)
  print(p)
}

# ---- Helper: save base R plots as .svg + .png ----
save_base_plot <- function(expr, name, width = 10, height = 7, dpi = 300) {
  png(file.path("plots", paste0(name, ".png")),
      width = width, height = height, units = "in", res = dpi)
  eval(expr)
  dev.off()

  svglite::svglite(file.path("plots", paste0(name, ".svg")),
                   width = width, height = height)
  eval(expr)
  dev.off()

  # Print inline
  eval(expr)
}
```

## Module 2: Load Tauber Reference Data

```{r load-reference, message=FALSE}

#Read Ref File.
reference <- readRDS(reference_path)

#Summary Info
cat("Reference object loaded:", ncol(reference), "cells,", nrow(reference), "genes\n")
cat("Assays:", paste(Assays(reference), collapse = ", "), "\n")

#Set Idents to Tissue of origin
Idents(reference) <- "orig.ident"


# Cell type labels are in Idents (already annotated)
cat("\nReference cell types:\n")
print(table(Idents(reference)))

# Store cell type labels in a metadata column for scPred
reference$cell_type <- as.character(Idents(reference))
```

## Module 3: Preprocess Reference for scPred

```{r preprocess-reference, message=FALSE}
# Ensure RNA assay is active with counts available
DefaultAssay(reference) <- "RNA"

reference <- NormalizeData(reference, verbose = FALSE)
reference <- FindVariableFeatures(reference, selection.method = "vst",
                                  nfeatures = 3000, verbose = FALSE)
reference <- ScaleData(reference, verbose = FALSE)
reference <- RunPCA(reference, npcs = min(50, ncol(reference) - 1), verbose = FALSE)
reference <- RunUMAP(reference, dims = 1:30, verbose = FALSE)

p_ref_umap <- DimPlot(reference, group.by = "cell_type", label = TRUE,
                       repel = TRUE) +
  ggtitle("Reference UMAP — Tauber Cell Types")
save_and_show(p_ref_umap, "tauber_ref_umap_celltypes")
```

## Module 4: Train scPred Model

```{r train-scpred, message=FALSE}

# Ensure RNA assay is active with counts available
DefaultAssay(reference) <- "decontX"

# Get informative feature space
reference <- getFeatureSpace(reference, "cell_type")

# Train the classifier (default: SVM with radial kernel)
reference <- trainModel(reference)

# Display model performance summary
cat("scPred model summary:\n")
get_scpred(reference)

# Plot training probabilities
p_train_prob <- plot_probabilities(reference)
save_and_show(p_train_prob, "tauber_scpred_training_probabilities")


```

## Module 5: Load Query Data

```{r load-query, message=FALSE}
query <- readRDS(query_path)
cat("Query object loaded:", ncol(query), "cells,", nrow(query), "genes\n")
cat("Assays:", paste(Assays(query), collapse = ", "), "\n")

# Ensure we work with the RNA assay and a single counts layer
DefaultAssay(query) <- "RNA"
a <- query[["RNA"]]

# If Seurat v5 with multiple counts layers, merge them
cnt_layers <- grep("^counts", Layers(a), value = TRUE)
if (length(cnt_layers) > 1) {
  cat("Merging", length(cnt_layers), "count layers ...\n")
  cnt_mats <- lapply(cnt_layers, function(L) {
    m <- GetAssayData(a, layer = L)
    if (!inherits(m, "dgCMatrix")) m <- as(m, "dgCMatrix")
    m
  })

  all_genes <- unique(unlist(lapply(cnt_mats, rownames)))
  align_mat <- function(m, genes_all) {
    out <- Matrix(0, nrow = length(genes_all), ncol = ncol(m), sparse = TRUE,
                  dimnames = list(genes_all, colnames(m)))
    keep <- match(rownames(m), genes_all)
    out[keep, ] <- m
    out
  }

  cnt_mats <- lapply(cnt_mats, align_mat, genes_all = all_genes)
  counts_merged <- do.call(cbind, cnt_mats)

  cells_all <- colnames(query)
  missing <- setdiff(cells_all, colnames(counts_merged))
  if (length(missing) > 0) {
    add0 <- Matrix(0, nrow = nrow(counts_merged), ncol = length(missing),
                   sparse = TRUE, dimnames = list(rownames(counts_merged), missing))
    counts_merged <- cbind(counts_merged, add0)
  }
  counts_merged <- counts_merged[, cells_all, drop = FALSE]
  rownames(counts_merged) <- make.unique(rownames(counts_merged))

  query[["RNA"]] <- CreateAssay5Object(counts = counts_merged)
  DefaultAssay(query) <- "RNA"
}

# Normalize and preprocess query
query <- NormalizeData(query, verbose = FALSE)
query <- FindVariableFeatures(query, selection.method = "vst",
                              nfeatures = 3000, verbose = FALSE)
query <- ScaleData(query, verbose = FALSE)
query <- RunPCA(query, npcs = min(50, ncol(query) - 1), verbose = FALSE)

# Compute UMAP if not already present
if (!"umap" %in% Reductions(query)) {
  query <- RunUMAP(query, dims = 1:30, verbose = FALSE)
}

# Cluster if not already clustered
if (is.null(query$seurat_clusters)) {
  query <- FindNeighbors(query, dims = 1:30, verbose = FALSE)
  query <- FindClusters(query, resolution = 0.5, verbose = FALSE)
}

cat("Query preprocessed:", ncol(query), "cells,", nrow(query), "genes\n")
```

## Module 6: scPred Classification

```{r scpred-classify, message=FALSE}
# Run scPred prediction on query with threshold = 0.75
query <- scPredict(query, reference, threshold = 0.75)

cat("Prediction summary:\n")
print(table(query$scpred_prediction))

# DimPlot of scPred predictions on query UMAP
p_pred <- DimPlot(query, group.by = "scpred_prediction", label = TRUE,
                  repel = TRUE) +
  ggtitle("scPred Predictions on Query UMAP (threshold ≥ 0.75)")
save_and_show(p_pred, "tauber_scpred_predictions_umap")
```

## Module 7: Top 3 Consensus Predictions per Query Cluster

```{r top3-predictions, message=FALSE, fig.width=12, fig.height=7}
# Cross-tabulate clusters vs predictions
ct <- table(Cluster = query$seurat_clusters, Prediction = query$scpred_prediction)
ct_df <- as.data.frame(ct)

# For each cluster, get top 3 predictions by frequency
top3_per_cluster <- ct_df %>%
  group_by(Cluster) %>%
  arrange(desc(Freq)) %>%
  slice_head(n = 3) %>%
  mutate(Rank = row_number()) %>%
  ungroup()

cat("Top 3 consensus predictions per query cluster:\n")
top3_wide <- top3_per_cluster %>%
  dplyr::select(Cluster, Rank, Prediction, Freq) %>%
  arrange(Cluster, Rank)
print(as.data.frame(top3_wide))

# Barplot: prediction composition per cluster (proportion)
p_bar <- ggplot(ct_df %>% filter(Freq > 0),
                aes(x = Cluster, y = Freq, fill = Prediction)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(title = "scPred Prediction Composition per Query Cluster (Tauber Ref)",
       x = "Query Cluster", y = "Proportion", fill = "Predicted Label") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
save_and_show(p_bar, "tauber_prediction_composition_barplot", width = 12, height = 7)

# Also create a count-based barplot
p_bar_count <- ggplot(ct_df %>% filter(Freq > 0),
                      aes(x = Cluster, y = Freq, fill = Prediction)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "scPred Prediction Counts per Query Cluster (Tauber Ref)",
       x = "Query Cluster", y = "Cell Count", fill = "Predicted Label") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
save_and_show(p_bar_count, "tauber_prediction_counts_barplot", width = 12, height = 7)
```

## Module 8: Project Prediction Scores onto Query UMAP

```{r prediction-scores-umap, message=FALSE, fig.width=12, fig.height=10}
# Get all scpred probability score columns
score_cols <- grep("^scpred_", colnames(query@meta.data), value = TRUE)
score_cols <- score_cols[sapply(query@meta.data[, score_cols, drop = FALSE], is.numeric)]
# Exclude the non-score columns
score_cols <- score_cols[!score_cols %in% c("scpred_prediction", "scpred_max",
                                             "scpred_no_prediction")]

cat("Prediction score columns to plot:\n")
print(score_cols)

# Plot each score on the query UMAP
for (sc in score_cols) {
  label_name <- sub("^scpred_", "", sc)
  p <- FeaturePlot(query, features = sc, reduction = "umap") +
    scale_colour_gradientn(colours = c("lightgrey", "yellow", "red")) +
    ggtitle(paste0("Prediction Score: ", label_name))
  save_and_show(p, paste0("tauber_score_umap_", label_name))
}
```

## Module 9: Validation Metrics

### scPred Internal Cross-Validation Metrics

```{r scpred-cv-metrics}
# scPred stores cross-validation results from training
cat("scPred model cross-validation performance:\n")
scpred_model <- get_scpred(reference)
print(scpred_model)
```

### Confusion Matrix: Query Clusters vs Predictions

```{r confusion-heatmap, fig.width=10, fig.height=8}
# Build confusion matrix (clusters vs scPred predictions)
conf_mat <- table(Cluster = query$seurat_clusters,
                  Prediction = query$scpred_prediction)

# Normalize by row (proportion within each cluster)
conf_prop <- prop.table(conf_mat, margin = 1)

# Plot as heatmap
save_base_plot(
  quote({
    pheatmap(conf_prop,
             color = colorRampPalette(c("white", "steelblue", "darkblue"))(100),
             cluster_rows = TRUE, cluster_cols = TRUE,
             display_numbers = TRUE, number_format = "%.2f",
             fontsize_number = 8,
             main = "Confusion Heatmap: Query Clusters vs scPred Predictions\n(Row-normalized proportions)")
  }),
  "tauber_confusion_heatmap"
)

# Also show raw counts version
save_base_plot(
  quote({
    pheatmap(conf_mat,
             color = colorRampPalette(c("white", "orange", "red"))(100),
             cluster_rows = TRUE, cluster_cols = TRUE,
             display_numbers = TRUE, number_format = "%d",
             fontsize_number = 8,
             main = "Confusion Heatmap: Query Clusters vs scPred Predictions\n(Raw counts)")
  }),
  "tauber_confusion_heatmap_counts"
)
```

### AuROC Analysis

```{r auroc-analysis, message=FALSE, fig.width=10, fig.height=8}
# Compute per-class AuROC using scPred probability scores
pred_labels <- query$scpred_prediction
unique_classes <- sort(unique(pred_labels))
unique_classes <- unique_classes[unique_classes != "unassigned"]

auroc_results <- data.frame(Class = character(), AuROC = numeric(),
                            stringsAsFactors = FALSE)

for (cls in unique_classes) {
  score_col <- paste0("scpred_", cls)
  if (score_col %in% colnames(query@meta.data)) {
    scores <- query@meta.data[[score_col]]
    binary_truth <- ifelse(pred_labels == cls, 1, 0)

    if (length(unique(binary_truth)) == 2) {
      roc_obj <- roc(binary_truth, scores, quiet = TRUE)
      auroc_results <- rbind(auroc_results,
                             data.frame(Class = cls, AuROC = auc(roc_obj)))
    }
  }
}

cat("Per-class AuROC (scPred scores vs. predicted labels):\n")
print(auroc_results)

# Bar plot of AuROC values
if (nrow(auroc_results) > 0) {
  p_auroc <- ggplot(auroc_results, aes(x = reorder(Class, AuROC), y = AuROC)) +
    geom_col(fill = "steelblue") +
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "red") +
    coord_flip() +
    ylim(0, 1) +
    labs(title = "Per-Class AuROC — scPred Predictions (Tauber Ref)",
         x = "Cell Type", y = "AuROC") +
    theme_minimal()
  save_and_show(p_auroc, "tauber_auroc_barplot")
}
```

### Prediction Confidence Distribution

```{r confidence-distribution, fig.width=10, fig.height=6}
# Distribution of max prediction scores
p_conf <- ggplot(query@meta.data, aes(x = scpred_max, fill = scpred_prediction)) +
  geom_histogram(bins = 50, alpha = 0.7) +
  geom_vline(xintercept = 0.75, linetype = "dashed", color = "red") +
  labs(title = "Distribution of Max scPred Prediction Scores (Tauber Ref)",
       x = "Max Prediction Score", y = "Count", fill = "Predicted Label") +
  theme_minimal()
save_and_show(p_conf, "tauber_prediction_score_distribution")
```

---

**Session Info**

```{r session-info}
sessionInfo()
```
